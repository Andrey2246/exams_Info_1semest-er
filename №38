//38.  Сортировка подсчетом. Выходной массив заполняется значениями “-1”.
//Затем для каждого элемента определяется его место в выходном массиве 
//путем подсчета количества элементов строго меньших данного. 
//Естественно, что все одинаковые элементы попадают на одну позицию, 
//за которой следует ряд значений “-1”. После чего оставшиеся в выходном 
//массиве позиции со значением “-1” заполняются копией предыдущего значения.
#include <stdio.h>
void sorting(int *arr, int n, int *ans){
    for(int i = 0; i < n; i++){
        int count = 0;
        for(int j = 0; j < n;j++){
            if (arr[j] < arr[i]){
                count++;
            }
        }
        ans[count]=arr[i];
        for(int j = 1; j < n;j++){
            if (ans[i] == -1){
                ans[i] = ans[i - 1];
            }
        }
    }
}
int main(){
    int arr[] = {8, 1, 6, 5, 4, 3, 2, 7};
    int ans[8];
    for(int i = 0; i < 8;i++){
        ans[i] = -1;
    }
    sorting(arr, 8, ans);
    for(int i = 0; i < 8;i++){
        printf("%d ", ans[i]);
    }
    printf("\n");


    int S1[]={556, 960, 972, 543, 815, 95, 535, 970, 703, 622, 940, 665, 151, 516, 30};
    int ans1[15];
    for(int i = 0; i < 15;i++){
        ans1[i] = -1;
    }
    sorting(S1, 15, ans1);
    for(int i = 0; i < 15;i++){
        printf("%d ", ans1[i]);
    }
    printf("\n");


    int S2[]= {955, 74, 548, 632, 140, 827, 639, 474, 219, 817, 731, 942, 389, 322};
    int ans2[14];
    for(int i = 0; i < 14;i++){
        ans2[i] = -1;
    }
    sorting(S2, 14, ans2);
    for(int i = 0; i < 14;i++){
        printf("%d ", ans2[i]);
    }
    printf("\n");


    int S3[]= {197, 240, 307, 465, 84, 638, 154, 795, 660, 825, 421, 205, 608, 330};
    int ans3[14];
    for(int i = 0; i < 14;i++){
        ans3[i] = -1;
    }
    sorting(S3, 14, ans3);
    for(int i = 0; i < 14;i++){
        printf("%d ", ans3[i]);
    }
    
}
